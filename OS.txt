5) String Processing

echo "hello world" | tr 'a-z' 'A-Z'
echo -e "one\ntwo\ntwo\nthree" | uniq
echo -e "c\na\nb" | sort
echo "user:x:1000:1000:User:/home/user:/bin/bash" | cut -d":" -f1
echo -e "error\nok\nerror" | grep "error"
echo -e "Error\nok\nERROR" | grep -i "error"
echo -e "root:x:0:0:root:/root:/bin/bash" | grep -n "root"
echo -e "cat\ndog\nfish" | egrep "cat|dog"
echo -e "success\nfail\nsuccess" | grep -v "success"
echo -e "foo bar\nfoo foo\nbar foo" | sed 's/foo/bar/g'
echo -e "line1\nline2\nline3\nline4\nline5" | sed -n '2,5p'
echo -e "one 1 three\nfour 2 six" | awk '{print $1,$3}'
echo -e "error found\nok done" | awk '/error/ {print $0}'
echo -e "123abc\nabc123\n456" | grep "^[0-9]"
echo -e "abcX\nxyzZ\nhello" | grep "[A-Z]$"
echo -e "111-22-3333\nabc-def\n999-88-7777" | grep -E "[0-9]{3}-[0-9]{2}-[0-9]{4}"






6) Deadlock

def bankers_algorithm(n, m, available, max_need, allocation):
    need = [[max_need[i][j] - allocation[i][j] for j in range(m)] for i in range(n)]
    finish = [False] * n
    safe_seq, work = [], available[:]
    while len(safe_seq) < n:
        found = False
        for i in range(n):
            if not finish[i] and all(need[i][j] <= work[j] for j in range(m)):
                work = [work[j] + allocation[i][j] for j in range(m)]
                finish[i], safe_seq, found = True, safe_seq + [i], True
        if not found: break
    return safe_seq if len(safe_seq) == n else None
def wait_for_graph_detection(wait_for):
    visited, stack = set(), set()
    def dfs(node):
        visited.add(node); stack.add(node)
        for nei in wait_for.get(node, []):
            if nei not in visited and dfs(nei): return True
            if nei in stack: return True
        stack.remove(node); return False
    return any(dfs(node) for node in wait_for if node not in visited)
n = int(input("Enter number of processes: "))
m = int(input("Enter number of resources: "))
available = list(map(int, input("Enter available resources: ").split()))
max_need, allocation = [], []
for i in range(n):
    max_need.append(list(map(int, input(f"Max need of P{i}: ").split())))
for i in range(n):
    allocation.append(list(map(int, input(f"Allocation of P{i}: ").split())))
safe = bankers_algorithm(n, m, available, max_need, allocation)
print("Safe sequence:", safe if safe else "No Safe Sequence")
edges = int(input("Enter edges in Wait-for graph: "))
wait_for = {}
for _ in range(edges):
    u, v = map(int, input("Edge u v: ").split())
    wait_for.setdefault(u, []).append(v)
print("Deadlock Detected?", wait_for_graph_detection(wait_for))






7) Memory Allocation

def first_fit(blocks, processes):
    alloc = [-1]*len(processes)
    for i, p in enumerate(processes):
        for j, b in enumerate(blocks):
            if b >= p:
                alloc[i], blocks[j] = j, b-p
                break
    return alloc

def best_fit(blocks, processes):
    alloc = [-1]*len(processes)
    for i, p in enumerate(processes):
        best = -1
        for j, b in enumerate(blocks):
            if b >= p and (best == -1 or blocks[j] < blocks[best]):
                best = j
        if best != -1:
            alloc[i], blocks[best] = best, blocks[best]-p
    return alloc

def worst_fit(blocks, processes):
    alloc = [-1]*len(processes)
    for i, p in enumerate(processes):
        worst = -1
        for j, b in enumerate(blocks):
            if b >= p and (worst == -1 or blocks[j] > blocks[worst]):
                worst = j
        if worst != -1:
            alloc[i], blocks[worst] = worst, blocks[worst]-p
    return alloc

n = int(input("Enter no. of blocks: "))
blocks = list(map(int, input("Enter block sizes: ").split()))
m = int(input("Enter no. of processes: "))
processes = list(map(int, input("Enter process sizes: ").split()))

print("First Fit:", first_fit(blocks[:], processes))
print("Best Fit:", best_fit(blocks[:], processes))
print("Worst Fit:", worst_fit(blocks[:], processes))








8) Page Replacement

def fifo(pages, capacity):
    frame, faults = [], 0
    for p in pages:
        if p not in frame:
            faults += 1
            if len(frame) < capacity: frame.append(p)
            else: frame.pop(0); frame.append(p)
    return faults

def lru(pages, capacity):
    frame, faults = [], 0
    for i, p in enumerate(pages):
        if p not in frame:
            faults += 1
            if len(frame) < capacity: frame.append(p)
            else:
                lru_index = min(range(len(frame)), key=lambda x: pages[:i][::-1].index(frame[x]) if frame[x] in pages[:i] else i)
                frame[lru_index] = p
    return faults

def optimal(pages, capacity):
    frame, faults = [], 0
    for i, p in enumerate(pages):
        if p not in frame:
            faults += 1
            if len(frame) < capacity: frame.append(p)
            else:
                future = {f: (pages[i+1:].index(f) if f in pages[i+1:] else float('inf')) for f in frame}
                victim = max(future, key=future.get)
                frame[frame.index(victim)] = p
    return faults

pages = list(map(int, input("Enter page reference string: ").split()))
cap = int(input("Enter frame capacity: "))

print("FIFO Page Faults:", fifo(pages, cap))
print("LRU Page Faults:", lru(pages, cap))
print("Optimal Page Faults:", optimal(pages, cap))







9) Disk Scheduling

def fcfs(req, head):
    dist = 0
    for r in req:
        dist += abs(head - r)
        head = r
    return dist

def sstf(req, head):
    dist, req = 0, req[:]
    while req:
        nearest = min(req, key=lambda x: abs(x-head))
        dist += abs(head - nearest)
        head = nearest
        req.remove(nearest)
    return dist

def scan(req, head, disk_size):
    req = sorted(req+[0, disk_size-1])
    idx = [i for i,v in enumerate(req) if v>=head][0]
    order = req[idx:]+req[:idx][::-1]
    dist, cur = 0, head
    for r in order:
        dist += abs(cur-r); cur = r
    return dist

def cscan(req, head, disk_size):
    req = sorted(req+[0, disk_size-1])
    idx = [i for i,v in enumerate(req) if v>=head][0]
    order = req[idx:]+req[:idx]
    dist, cur = 0, head
    for r in order:
        dist += abs(cur-r); cur = r
    return dist

n = int(input("Enter number of requests: "))
req = list(map(int, input("Enter request sequence: ").split()))
head = int(input("Enter initial head position: "))
disk_size = int(input("Enter disk size: "))

print("FCFS:", fcfs(req, head))
print("SSTF:", sstf(req, head))
print("SCAN:", scan(req, head, disk_size))
print("C-SCAN:", cscan(req, head, disk_size))



